\section{Instruction validation}

One of the most essential ways to provide results of the parsing to the user is through error messages. Many of these messages are created in \emph{Instruction checker} which validates the usage of different kinds of instructions.

Instruction checker is an interface for various types of instructions. Its \emph{check()} method is being called from the instruction processors~\ref{chap:process} to check whether the specific instructions is used with correct parameters. As assembler and machine instructions have incoherent formats, we derive separate \emph{assembler} and \emph{machine} checkers from the instruction checker. Note that CA instructions do not have a derived checker class as they are all being checked during their interpretation. Checkers are by design stateless.

The checkers need an access to the definitions of all possible instructions. These are stored statically inside one object called \emph{instruction}. There are 4 different containers:
\begin{itemize}
	\item \emph{machine\_instructions} is a map of instruction names to machine instruction object, which contains various data such as format, size, vector of its operands.
	\item \emph{mnemonic\_codes} maps instruction names to their mnemonic code objects. These provide a list of operands to be substituted along with the original instruction name.
	\item \emph{assembler\_instructions} are similar to the machine instructions. However, as the assembler instructions do not have formats, these classes only contain the information about minimum/maximum number of operands for specific instruction. In~\cref{sub:asm_check}, we explain how the assembler instructions are resolved.
	\item \emph{ca\_instruction} only contains a list of possible CA instructions.
\end{itemize}

Both checkers work in a similar manner:
\begin{enumerate}
	\item Either assembler or machine processor calls the check() method of its respective checker. This method accepts the instruction name, the vector of used operands, the range of statement and the diagnostic collector.
	\item Checker finds the correct instruction based on the provided name and calls the check() method of its instruction class, along with the same parameters mentioned above.
	\item The instruction itself compares its possible operands with the used operands.
	\item More validations may be necessary, based on the instruction.
	\item In case of mismatch, a diagnostic is added to the passed diagnostic container.
\end{enumerate}

\subsection{Machine instruction checker}

All machine instructions have a precisely defined format which makes the validation based on these formats simple. Machine instruction checker operates with machine instructions and their mnemonic codes. It works  compares the actual used operands with the vector of possible operands and, in case of mismatch, creates a diagnostic within the diagnostic container.

The formats are pretty straightforward. They define several basic operands such as register or address and state which combination of these operands are acceptable. For example, instruction LR has format RR, which means it accepts only 2 arbitrary (but correct) registers. 

\subsection{Assembler instruction checker}
\label{sub:asm_check}

Validation of assembler instructions is more complicated as there are no pre-defined formats for them. Each of them is described by custom operand diagrams, which demonstrate the dependencies and relations between different operands of the same instruction. As addition to the basic operands used for machine instructions, each assembler instruction might have its own, called keywords.

Due to these irregularities, we derive instruction-specific classes from assembler instruction class. Each of them implements the check() method, keeping the results from them similar.

