\chapter{Supported features}

This chapter reviews the specific goals of our project.
All the features below have been discussed with professional HLASM developers and have been agreed on by the company.

This project is distributed as a VS Code extension, downloadable from the  \href{https://marketplace.visualstudio.com/}{Market Place}, or directly from the VS Code application The extension contains all executables/libraries that are needed for the project to work correctly on the most popular platforms. No other prerequisites should be required.

\section{Supported LSP features}
This section demonstrates the possible uses of the extension on the client side. LSP provides a list of well-defined features. The project implements the following:

\begin{itemize}
	\item The back-end semantically and syntactically checks all instructions (including machine instructions) for correct operand format usage. However, it does not analyze the run-time register and memory values, as there is no machine instruction interpretation.
	\item \texttt{Go to definition} command for all symbols, macro definitions and copy members\footnote{Copy, along with macro expansion, is a mean to include another external file, invoked by \texttt{COPY} instruction. Comparing to macro, copy does not neither need to start nor end with any specific instruction and the invoking \texttt{COPY} instruction is simply replaced by the COPY file's contents.}
	\item \texttt{Find all references} command for all symbols, macro definitions and copy members
	\item Completion for instructions, defined symbols and macros
	\item Mouse-over tooltip (hover) for symbol attributes, their locations, contents and other useful information depending on the symbol type

	\item Server-side Highlighting for all symbols which is our custom extension of LSP  
\end{itemize}

\section{Highlighting}

The highlighting is not a standard part of the LSP, nonetheless it is a needed addition. Due to the complexity of HLASM, a typical syntax highlighting is not sufficient. Consider following examples:

\lstdefinelanguage{HLASM}{
	keywords = [1]{REMARK},
	keywords = [2]{SAM31,LR,AGO,AIF,ICTL},
	keywords = [3]{J,SYMBOL},
	keywords = [4]{IGNORED},
	keywords = [5]{X},
	keywordstyle = [1]\color{blue},
	keywordstyle = [2]\color{red},
	keywordstyle = [3]\color{white},
	keywordstyle = [4]\color{magenta},
	keywordstyle = [5]\color{cyan}
}
\lstset{
	numbers=left, 
	numberstyle=\small, 
	numbersep=8pt, 
	frame = single, 
	language=HLASM, 
	framexleftmargin=15pt,
	backgroundcolor = \color{lightgray}
}
\begin{itemize}
	\item The language server recognizes operand formats of different instructions. The most simple example is the \texttt{SAM31} instruction, which does not have any operands, while the \texttt{LR} instruction takes two. So the identifier right after \texttt{SAM31} is colored blue as a remark. 
	
	\begin{lstlisting}
	SAM31 REMARK
	LR    1,1   REMARK
	\end{lstlisting}
	
	\item The code skipped by the conditional assembly is not colored and stays white.
	\begin{lstlisting}
	AGO .HERE
	J   SYMBOL
	.HERE AIF
	\end{lstlisting}
	
\end{itemize}


\section{Continuation Handling}

Fixed-size lines are another aspect of HLASM that needs to be handled. They make the parsing more difficult, as the position of the continuation character may vary. 

We also add a continuation handling option to the IDE, which mostly consists of non-movable continuation characters, i.e. if the user types in front of the continuation character, it stays in place.

\todo{how to switch on}
\todo{specific keyboard shortcuts to invoke the functionality}


\section{Macro Tracer}

How to start macro tracer

step in - goes inside macros and copy instructions

step over - doesnt

stack trace explanation

variables view



To trace the code generation, the user can step through the code while watching the contents of variables and the call stack using \texttt{Macro tracer}. We implement \texttt{Debug Adapter Protocol} so that the process resembles standard debugging.